Tool:-Vite application
------>npm create vite@latest my-app


//What is the useEffect Hook?
React's useEffect hook allows you to perform side effects in your components.
Examples of side effects include API calls, manually changing the DOM, and subscriptions.

//The basic syntax of useEffect is:
  useEffect(callbackFunction, dependencyArray);

//callbackFunction: The function where your side effect code will be placed. This function is executed after every completed render by default.
dependencyArray: An optional array that determines when the useEffect callback should be re-invoked.
If it's empty ([]), the effect runs only once after the initial render, mimicking the behavior of componentDidMount in class components.
------------------------------------------------------------------------------------------------
Note:-The default behaviour of useEffect is that it get triggered at mount and unmount pahase.
      If the dependency array is empty it will not be triggered for any update.
      We can pass multiple values inside dependency array

Ex:-
import { useState, useEffect } from "react";

function App() {
  const [count, setCount] = useState(0);
  useEffect(() => {
    document.title = `You clicked ${count} times`;
  });

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}

//Side Effects, useEffect and Update Phase:-
In React, managing side effects efficiently is crucial for creating responsive and performant web applications.
The useEffect hook, a fundamental part of React's Hooks API, provides a streamlined way to handle side effects not only after the initial mount but also during component updates.
This lesson focuses on leveraging useEffect during the update phase, illustrating basic to advanced examples to deepen your understanding.

//The useEffect Hook Basics
useEffect allows you to perform side effects in your function components. 
It takes two arguments: a callback function where the side effect occurs, and an optional dependency array that controls the execution of the effect based on state or prop changes.

Dependency Array and Update Phase
The dependency array plays a pivotal role in controlling when the useEffect callback is called:

No dependency array: The effect runs after every render.
Empty dependency array ([]): The effect runs once, similar to componentDidMount.
Variables in the dependency array: The effect runs when any of the listed variables change, enabling fine control over the effect's execution during component updates.

Ex:-
//function App() {
  const [count, setCount] = useState(0);
  useEffect(() => {
    document.title = `Count is ${count}`;
  }, [count]); // Effect depends on count
  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={() => setCount(count + 1)}>Increase Count</button>
    </div>
  );
}

//Side Effects, useEffect and Unmount Phase:-
Understanding the Unmount Phase
The unmount phase occurs when a component is removed from the DOM. 
Similar to turning off unnecessary appliances when leaving a room, 
this phase is critical for cleaning up resources allocated by the component, such as timers, event listeners, or subscriptions.

The Importance of Cleanup in useEffect
React's useEffect hook not only allows us to perform side effects after rendering but also provides a mechanism for cleanup via a return function.
This cleanup function is executed when the component is unmounted, making it an ideal place to release resources and prevent memory leaks.

Ex:-Initial Timer Component Without Cleanup
// Initial Timer component that leads to memory leak
function Timer() {
  useEffect(() => {
    setInterval(() => {
      console.log(`This code runs every 1 second`, Date.now());
    }, 1000);
  }, []);
  return <h1>Timer</h1>;
}

//Observations
Without cleanup, the interval continues to run in the background even after the Timer component is unmounted,
 consuming resources unnecessarily and potentially leading to application performance issues.

 //Implementing Cleanup
To prevent this, we can use a cleanup function in useEffect to clear the interval when the component unmounts:

function Timer() {
  useEffect(() => {
    const intervalId = setInterval(() => {
      console.log(`This code runs every 1 second`, Date.now());
    }, 1000);

    // Cleanup function
    return () => {
      clearInterval(intervalId);
    };
  }, []);
  return <h1>Timer</h1>;
}

-----------------------------------------------------------------
//Handling data fetching 
Ex:-
import React, { useEffect, useState } from "react";

const ApiComponent = () => {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(false);

  useEffect(() => {
    async function fetchData() {
      setLoading(true);
      try {
        const response = await fetch(
          "https://jsonplaceholder.typicode.com/post",
        );

        if (!response.ok) {
          throw new Error("Failed to fetch data");
        }
        let result = await response.json();
        setData(result);
        console.log(result);
      } catch (error) {
        setError(error.message);
      } finally {
        setLoading(false);
      }
    }
    fetchData();
  }, []);
  if (loading) {
    return <h1>Loading.....</h1>;
  }
  if (error) {
    return <h1>Error: {error}</h1>;
  }

  return (
    <div>
      <h1>Fetching data from Api:</h1>
      <ul>
        {data.slice(0, 20).map((item) => (
          <li key={item.id}>{item.title}</li>
        ))}
      </ul>
    </div>
  );
};

export default ApiComponent;
-------------------------------------------------------------------

//material icon theme
///

// Handling side effects
Ex:-
const TimerComponent = () => {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    console.log("component mounted");

    return () => {
      console.log("Component unmounted");
    };
  });

  useEffect(() => {
    console.log("Timer started");
    let timer = setInterval(() => {
      setSeconds((prev) => prev + 1);
      console.log(`Seconds ${seconds}s`);
    }, 1000);

    return () => {
      clearInterval(timer);
      console.log("Timer stopped");
    };
  }, []);

  return (
    <div>
      <h1>Time in: {seconds}s</h1>
    </div>
  );
};